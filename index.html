<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        
        <title>reveal.js</title>

        <link rel="stylesheet" href="dist/reset.css">
        <link rel="stylesheet" href="dist/reveal.css">
        <link rel="stylesheet" href="dist/theme/black.css">

        <!-- Theme used for syntax highlighted code -->
        <link rel="stylesheet" href="plugin/highlight/monokai.css">
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                  Global HKers Book Club <p style="color:blue">Effective Python</p>
                </section>
                <section>
                    <section>Item 1</section>
                    <section>Know Which Version of Python You’re Using</section>
                    <section>
                       <pre><code data-trim data-noescape>
                           $ python --version
                           Python 2.7.10
                       </code></pre>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                           $ python3 --version
                           Python 3.8.0
                        </code></pre>
                     </section>
                </section>
                <section>
                    <section>Item 2</section>
                    <section>Follow the PEP 8 Style Guide</section>
                </section>
                <section>
                    <section>Item 3</section>
                    <section>Know the Differences Between bytes and str</section>
                    <section><b style="color:green">bytes</b> contains sequences of 8-bit values, and <b style="color:green">str</b> contains sequences of Unicode code points.</section>
                    <section><b style="color:green">bytes</b> and <b style="color:green">str</b> instances can’t be used together with operators</section>
                    <section data-markdown>
                       <textarea data-template>
                         ```python
                         a = b'h\x65llo'
                         print(list(a))
                         print(a)
                         ```
                         ```text
                         >>>
                         [104, 101, 108, 108, 111]
                         b'hello'
                         ```
                       </textarea>
                    </section>
                    <section data-markdown>
                       <textarea data-template>
                         ```python
                         a = 'a\u0300 propos'
                         print(list(a))
                         print(a)
                         ```
                         ```text
                         >>>
                         ['a', 'ˋ', ' ', 'p', 'r', 'o', 'p', 'o', 's']
                         à propos
                         ```
                       </textarea>
                    </section>
                    <section data-markdown>
                       <textarea data-template>
                         ```python
                         print(b'one' + b'two')
                         print('one' + 'two')
                         ```
                         ```text
                         >>>
                         b'onetwo'
                         onetwo
                         ```
                       </textarea>
                    </section>
                    <section data-markdown>
                       <textarea data-template>
                         ```python
                         b'one' + 'two'
                         ```
                         ```text
                         >>>
                         Traceback ...
                         TypeError: can't concat str to bytes
                         ```
                       </textarea>
                    </section>
                    <section data-markdown>
                       <textarea data-template>
                         ```python
                         'one' + b'two'
                         ```
                         ```text
                         >>>
                         Traceback ...
                         TypeError: can only concatenate str (not "bytes") to str
                         ```
                       </textarea>
                    </section>
                </section>
                <section>
                    <section>Item 4</section>
                    <section>Prefer Interpolated F-Strings Over C-style Format Strings and str.format</section>
                    <section data-markdown>
                        <textarea data-template>
                          Four ways to do string formatting
                          1. C-style string using &#37; operator
                          2. Use string built-in str.format
                          3. Use f-strings
                          4. Use [templates strings](https://realpython.com/python-string-formatting/#4-template-strings-standard-library) (Not mentioned in this item)
                        </textarea>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                          C-style string using &#37; operator
                          ```python
                          a = 0b10111011
                          b = 0xc5f
                          print('Binary is %d, hex is %d' % (a, b))
                          ```
                          ```text
                          >>>
                          Binary is 187, hex is 3167
                          ```
                        </textarea>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                          C-style string using &#37; operator
                          ```python
                          key = 'my_var'
                          value = 1.234
                          formatted = '%-10s = %.2f' % (key, value)
                          print(formatted)
                          ```
                          ```text
                          >>>
                          my_var     = 1.23
                          ```
                        </textarea>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                          Order of data vlues in the tuple matters.
                          ```python
                          reordered_tuple = '%-10s = %.2f' % (value, key)
                          ```
                          ```text
                          >>>
                          Traceback ...
                          TypeError: must be real number, not str
                          ```
                        </textarea>
                    </section>
                    <section data-markdown>
                      <textarea data-template>
                        Small modifications to values make the expression difficult to read.
                        ```python
                        pantry = [
                            ('avocados', 1.25),
                            ('bananas', 2.5),
                            ('cherries', 15),
                        ]
                        for i, (item, count) in enumerate(pantry):
                            print('#%d: %-10s = %.2f' % (i, item, count))
                        ```
                        ```text
                        >>>
                        #0: avocados    = 1.25
                        #1: bananas     = 2.50
                        #2: cherries    = 15.00
                        ```
                      </textarea>
                    </section>
                    <section data-markdown>
                      <textarea data-template>
                        Small modifications to values make the expression difficult to read.
                        ```python
                        for i, (item, count) in enumerate(pantry):
                        print('#%d: %-10s = %d' % (
                            i + 1,
                            item.title(),
                            round(count)))
                        ```
                        ```text
                        >>>
                        #1: Avocados   = 1
                        #2: Bananas    = 2
                        #3: Cherries   = 15
                        ```
                      </textarea>
                    </section>
                    <section data-markdown>
                      <textarea data-template>
                        Need to repeat a value if you need it in different places of the expression.
                        ```python
                        template = '%s loves food. See %s cook.'
                        name = 'Max'
                        formatted = template % (name, name)
                        print(formatted)
                        ```
                        ```text
                        >>>
                        Max loves food. See Max cook.
                        ```
                      </textarea>
                    </section>
                    <section data-markdown>
                      <textarea data-template>
                        Use dictionaries to solve the order issue
                        ```python
                        key = 'my_var'
                        value = 1.234
                        
                        old_way = '%-10s = %.2f' % (key, value)
                        
                        new_way = '%(key)-10s = %(value).2f' % {
                            'key': key, 'value': value} # Original
                        
                        reordered = '%(key)-10s = %(value).2f' % {
                            'value': value, 'key': key} # Swapped
                        
                        assert old_way == new_way == reordered
                        ```
                      </textarea>
                    </section>
                    <section data-markdown>
                      <textarea data-template>
                        Use dictionaries to solve the need of same value in multiple places.
                        ```python
                        name = 'Max'


                        template = '%s loves food. See %s cook.'
                        before = template % (name, name) # Tuple
                        
                        
                        template = '%(name)s loves food. See %(name)s cook.'
                        after = template % {'name': name} # Dictionary
                        
                        
                        assert before == after
                        ```
                      </textarea>
                    </section>
                    <section data-markdown>
                      <textarea data-template>
                        However, dictionary format strings introduce and exacerbate verbosity.
                        ```python
                        for i, (item, count) in enumerate(pantry):
                            before = '#%d: %-10s = %d' % (
                                i + 1,
                                item.title(),
                                round(count))
                        
                            after = '#%(loop)d: %(item)-10s = %(count)d' % {
                                'loop': i + 1,
                                'item': item.title(),
                                'count': round(count),
                            }
                        
                            assert before == after
                        ```
                      </textarea>
                    </section>
                    <section data-markdown>
                      <textarea data-template>
                        Using the format built-in and str.format
                        ```python
                        a = 1234.5678
                        formatted = format(a, ',.2f')
                        print(formatted)
                        
                        b = 'my string'
                        formatted = format(b, '^20s')
                        print('*', formatted, '*')
                        ```
                        ```text
                        >>>
                        1,234.57
                        *     my string     *
                        ```
                      </textarea>
                    </section>
                    <section data-markdown>
                      <textarea data-template>
                        Using the format built-in and str.format
                        ```python
                        key = 'my_var'
                        value = 1.234
                        
                        formatted = '{} = {}'.format(key, value)
                        print(formatted)
                        ```
                        ```text
                        >>>
                        my_var = 1.234
                        ```
                      </textarea>
                    </section>
                    <section data-markdown>
                      <textarea data-template>
                        Using the format built-in and str.format to avoid problem #1
                        ```python
                        formatted = '{1} = {0}'.format(key, value)
                        print(formatted)
                        ```
                        ```text
                        >>>
                        1.234 = my_var
                        ```
                      </textarea>
                    </section>
                    <section data-markdown>
                      <textarea data-template>
                        Using the format built-in and str.format to avoid problem #3
                        ```python
                        formatted = '{0} loves food. See {0} cook.'.format(name)
                        print(formatted)
                        ```
                        ```text
                        >>>
                        Max loves food. See Max cook.
                        ```
                      </textarea>
                    </section>
                    <section data-markdown>
                      <textarea data-template>
                        Using the format built-in and str.format doesn't address problem #2
                        ```python
                        for i, (item, count) in enumerate(pantry):
                            old_style = '#%d: %-10s = %d' % (
                                i + 1,
                                item.title(),
                                round(count))
                            new_style = '#{}: {:<10s} = {}'.format(
                                i + 1,
                                item.title(),
                                round(count))
                            
                            assert old_style == new_style
                        ```
                      </textarea>
                    </section>
                    <section data-markdown>
                      <textarea data-template>
                        Using the format built-in and str.format also doesn't address problem #4
                        ```python
                        old_template = (
                            'Today\'s soup is %(soup)s, '
                            'buy one get two %(oyster)s oysters, '
                            'and our special entrée is %(special)s.')
                        old_formatted = template % {
                            'soup': 'lentil',
                            'oyster': 'kumamoto',
                            'special': 'schnitzel',
                        }
                        
                        new_template = (
                            'Today\'s soup is {soup}, '
                            'buy one get two {oyster} oysters, '
                            'and our special entrée is {special}.')
                        new_formatted = new_template.format(
                            soup='lentil',
                            oyster='kumamoto',
                            special='schnitzel',
                        )

                        assert old_formatted == new_formatted
                        ```
                      </textarea>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                          Issue with C-style Format
                          1. Order of data vlues in the tuple matters.
                          2. Small modifications to values make the expression difficult to read.
                          3. Need to repeat the value if you need it in multiple places of the expression.
                          4. Use dictionaries solve some of the problems above, but increase verbosity.
                        </textarea>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            | Issue Fixed? | (1) | (2) | (3) | (4) |
                            | ----------- | ----------- | ----------- | ----------- | ----------- |
                            | c-style | &#10060; | &#10060; |&#10060; | &#10060; |
                            | str.format | &#9989; | &#10060; | &#9989; | &#10060; |
                            | f-strings | &#9989; | &#9989; | &#9989; | &#9989; |
                        </textarea>
                    </section>
                    <section data-markdown>
                      <textarea data-template>
                        Using the interpolated format strings is the best way after Python 3.6
                        ```python
                        key = 'my_var'
                        value = 1.234
                        
                        formatted = f'{key} = {value}'
                        print(formatted)
                        ```
                        ```text
                        >>>
                        my_var = 1.234
                        ```
                      </textarea>
                    </section>
                    <section data-markdown>
                      <textarea data-template>
                        Note there is no need for using dictionaries
                        ```python
                        key = 'my_var'
                        value = 1.234
                        
                        formatted = f'{key} = {value}'
                        print(formatted)
                        ```
                        ```text
                        >>>
                        my_var = 1.234
                        ```
                      </textarea>
                    </section>

                    <section data-markdown>
                      <textarea data-template>
                        Using the interpolated format strings can deal with problem #1 & #3
                        ```python
                        key = 'my_var'
                        value = 1.234
                        
                        formatted = f'{key!r:<10} = {value:.2f}'
                        print(formatted)
                        ```
                        ```text
                        >>>
                        my_var   = 1.23
                        ```
                      </textarea>
                    </section>

                    <section data-markdown>
                      <textarea data-template>
                        Using the interpolated format strings solve problem #2
                        ```python
                        for i, (item, count) in enumerate(pantry):
                            old_style = '#%d: %-10s = %d' % (
                                i + 1,
                                item.title(),
                                round(count))
                        
                            new_style = '#{}: {:<10s} = {}'.format(
                                i + 1,
                                item.title(),
                                round(count))

                            f_string = f'#{i+1}: {item.title():<10s} = {round(count)}'

                            assert old_style == new_style == f_string
                        ```
                      </textarea>
                    </section>

                </section>
                <section>
                  <section>Item 5</section>
                  <section>Write Helper Functions Instead of Complex Expressions</section>
                  <section>Python’s <b style="color:green">syntax</b> makes it easy to write <b style="color:blue">single-line expressions</b> that are overly <b style="color:red">complicated</b> and <b style="color:red">difficult</b> to read.</section>
                  <section data-markdown>
                     <textarea data-template>
                       ```python
                       from urllib.parse import parse_qs
                       
                       my_values = parse_qs('red=5&blue=0&green=',
                                            keep_blank_values=True)
                       print(repr(my_values))
                       ```
                       ```text
                       >>>
                       {'red': ['5'], 'blue': ['0'], 'green': ['']}
                       ```
                     </textarea>
                  </section>
                  <section data-markdown>
                     <textarea data-template>
                       ```python 
                       print('Red:     ', my_values.get('red'))
                       print('Green:   ', my_values.get('green'))
                       print('Opacity: ', my_values.get('opacity'))
                       ```
                       ```text
                       >>>
                       Red:      ['5']
                       Green:    ['']
                       Opacity:  None
                       ```
                     </textarea>
                  </section>
                  <section data-markdown>
                    <textarea data-template>
                      ```python 
                      # For query string 'red=5&blue=0&green='
                      red = my_values.get('red', [''])[0] or 0
                      green = my_values.get('green', [''])[0] or 0
                      opacity = my_values.get('opacity', [''])[0] or 0
                      print(f'Red:     {red!r}')
                      print(f'Green:   {green!r}')
                      print(f'Opacity: {opacity!r}')
                      ```
                      ```text
                      >>>
                      Red:     '5'
                      Green:   0
                      Opacity: 0
                      ```
                    </textarea>
                  </section>
                  <section>An <u>if/else</u> expression provides a more readable alternative to using the Boolean operators <u>or</u> and <u>and</u> in expressions.</section>
                  <section data-markdown>
                   <textarea data-template>
                     ```python 
                     red = int(my_values.get('red', [''])[0] or 0)
                     ```
                     ```python
                     red_str = my_values.get('red', [''])
                     red = int(red_str[0]) if red_str[0] else 0
                     ```
                   </textarea>
                  </section>
                  <section data-markdown>
                    <textarea data-template>
                      ```python 
                      green_str = my_values.get('green', [''])
                      if green_str[0]:
                          green = int(green_str[0])
                      else:
                          green = 0
                      ```
                    </textarea>
                   </section>
                   <section>Move complex expressions into helper functions, especially if you need to use the same logic repeatedly.</section>
                   <section data-markdown>
                    <textarea data-template>
                      ```python 
                      def get_first_int(values, key, default=0):
                          found = values.get(key, [''])
                          
                          if found[0]:
                             return int(found[0])
                          return default
                      ```
                    </textarea>
                   </section>
               
                </section>
                <section>
                  <section>Item 6</section>
                  <section>Prefer Multiple Assignment Unpacking Over Indexing</section>
                  <section>Python has a built-in <u>tuple</u> type that can be used to create <u>immutable</u>, <u>ordered</u> sequences of values.</section>
                  <section data-markdown>
                     <textarea data-template>
                       ```python
                       snack_calories = {
                           'chips': 140,
                           'popcorn': 80,
                           'nuts': 190,
                       }
                       items = tuple(snack_calories.items())
                       print(items)
                       ```
                       ```text
                       >>>
                       (('chips', 140), ('popcorn', 80), ('nuts', 190))
                       ```
                     </textarea>
                  </section>
                  <section data-markdown>
                    <textarea data-template>
                      ```python
                      item = ('Peanut butter', 'Jelly')
                      first = item[0]
                      second = item[1]
                      print(first, 'and', second)
                      ```
                      ```text
                      >>>
                      Peanut butter and Jelly
                      ```
                    </textarea>
                  </section>
                  <section data-markdown>
                   <textarea data-template>
                     ```python
                     pair = ('Chocolate', 'Peanut butter')
                     pair[0] = 'Honey'
                     ```
                     ```text
                     >>>
                     Traceback ...
                     TypeError: 'tuple' object does not support item assignment
                     ```
                   </textarea>
                  </section>
                  <section>Python has special syntax called unpacking for assigning multiple values in a single statement.</section>
                  <section data-markdown>
                    <textarea data-template>
                      ```python
                      item = ('Peanut butter', 'Jelly')
                      first, second = item # Unpacking
                      print(first, 'and', second)
                      ```
                      ```text
                      >>>
                      Peanut butter and Jelly
                      ```
                    </textarea>
                  </section>
                  <section>Unpacking is generalized in Python and can be applied to any iterable, including many levels of iterables within iterables.</section>
                  <section data-markdown>
                    <textarea data-template>
                      ```python
                      favorite_snacks = {
                          'salty': ('pretzels', 100),
                          'sweet': ('cookies', 180),
                          'veggie': ('carrots', 20),
                      }
                      ((type1, (name1, cals1)),
                       (type2, (name2, cals2)),
                       (type3, (name3, cals3))) = favorite_snacks.items()
                      
                      print(f'Favorite {type1} is {name1} with {cals1} calories')
                      print(f'Favorite {type2} is {name2} with {cals2} calories')
                      print(f'Favorite {type3} is {name3} with {cals3} calories')
                      ```
                      ```text
                      >>>
                      Favorite salty is pretzels with 100 calories
                      Favorite sweet is cookies with 180 calories
                      Favorite veggie is carrots with 20 calories
                      ```
                    </textarea>
                  </section>
                  <section>Unpacking can even be used to swap values in place</section>
                  <section data-markdown>
                    <textarea data-template>
                      ```python
                      def bubble_sort(a):
                          for _ in range(len(a)):
                              for i in range(1, len(a)):
                                  if a[i] < a[i-1]:
                                      temp = a[i]
                                      a[i] = a[i-1]
                                      a[i-1] = temp
                      ```
                      ```python
                      def bubble_sort(a):
                          for _ in range(len(a)):
                              for i in range(1, len(a)):
                                  if a[i] < a[i-1]:
                                      a[i-1], a[i] = a[i], a[i-1] # Swap
                      ```
                    </textarea>
                  </section>
                  <section data-markdown>
                    <textarea data-template>
                      ```python
                      snacks = [('bacon', 350), ('donut', 240), ('muffin', 190)]

                      for i in range(len(snacks)):
                          item = snacks[i]
                          name = item[0]
                          calories = item[1]
                          print(f'#{i+1}: {name} has {calories} calories')
                      ```
                      ```python
                      for rank, (name, calories) in enumerate(snacks, 1):
                          print(f'#{rank}: {name} has {calories} calories')
                      ```
                      ```text
                      >>>
                      #1: bacon has 350 calories
                      #2: donut has 240 calories
                      #3: muffin has 190 calories
                      ```
                    </textarea>
                  </section>
                  <section>Reduce visual noise and increase code clarity by using unpacking to avoid explicitly indexing into sequences.</section>

                </section>
                <section>
                  <section>Item 7</section>
                  <section>Prefer <u>enumerate</u> Over <u>range</u></section>
                  <section>The <u>range</u> built-in function is useful for loops that iterate over a set of integers</section>
                  <section data-markdown>
                     <textarea data-template>
                       ```python
                       from random import randint

                       random_bits = 0
                       for i in range(32):
                           if randint(0, 1):
                               random_bits |= 1 << i
                       
                       print(bin(random_bits))
                       ```
                       ```text
                       >>>
                       0b11101000100100000111000010000001
                       ```
                     </textarea>
                  </section>
                  <section data-markdown>
                    <textarea data-template>
                      ```python
                      flavor_list = ['vanilla', 'chocolate', 'pecan', 'strawberry']
                      for flavor in flavor_list:
                          print(f'{flavor} is delicious')
                      ```
                      ```text
                      >>>
                      vanilla is delicious
                      chocolate is delicious
                      pecan is delicious
                      strawberry is delicious
                      ```
                    </textarea>
                  </section>
                  <section>What happens if you need both the <u>index</u> and <u>content</u> of the list?</section>
                  <section data-markdown>
                   <textarea data-template>
                     ```python
                     for i in range(len(flavor_list)):
                         flavor = flavor_list[i]
                         print(f'{i + 1}: {flavor}')
                     ```
                     ```text
                     >>>
                     1: vanilla
                     2: chocolate
                     3: pecan
                     4: strawberry
                     ```
                   </textarea>
                  </section>
                  <section><u>enumerate</u> provides concise syntax for looping over an iterator and getting the index of each item from the iterator as you go.</section>
                  <section data-markdown>
                    <textarea data-template>
                      ```python
                      it = enumerate(flavor_list)
                      print(next(it))
                      print(next(it))
                      ```
                      ```text
                      >>>
                      (0, 'vanilla')
                      (1, 'chocolate')
                      ```
                    </textarea>
                  </section>
                  <section data-markdown>
                    <textarea data-template>
                      ```python
                      for i, flavor in enumerate(flavor_list):
                          print(f'{i + 1}: {flavor}')
                      ```
                      ```text
                      >>>
                      1: vanilla
                      2: chocolate
                      3: pecan
                      4: strawberry
                      ```
                    </textarea>
                  </section>
                  <section>You can supply a second parameter to enumerate to specify the number from which to begin counting (zero is the default).</section>
                  <section data-markdown>
                    <textarea data-template>
                      ```python
                      for i, flavor in enumerate(flavor_list, 1):
                          print(f'{i}: {flavor}')
                      ```
                    </textarea>
                  </section>
                </section>
                <section>
                  <section>Item 8</section>
                  <section>Use <u>zip</u> to Process Iterators in Parallel</section>
                  <section>Often in Python you find yourself working with many lists of related objects.</section>
                  <section data-markdown>
                     <textarea data-template>
                       ```python
                       names = ['Cecilia', 'Lise', 'Marie']
                       counts = [len(n) for n in names]
                       print(counts)
                       ```
                       ```text
                       >>>
                       [7, 4, 5]
                       ```
                     </textarea>
                  </section>
                  <section data-markdown>
                    <textarea data-template>
                      ```python
                      longest_name = None
                      max_count = 0
                      
                      for i in range(len(names)):
                          count = counts[i]
                          if count > max_count:
                             longest_name = names[i]
                             max_count = count
                      
                      print(longest_name)
                      ```
                      ```text
                      >>>
                      Cecilia
                      ```
                    </textarea>
                  </section>
                  <section data-markdown>
                   <textarea data-template>
                     ```python
                     for i, name in enumerate(names):
                         count = counts[i]
                         if count > max_count:
                             longest_name = name
                             max_count = count
                     ```
                   </textarea>
                  </section>
                  <section data-markdown>
                   <textarea data-template>
                     ```python
                     for name, count in zip(names, counts):
                         if count > max_count:
                             longest_name = name
                             max_count = count
                     ```
                   </textarea>
                  </section>
                  <section>However, beware of zip’s behavior when the input iterators are of different lengths.</section>
                  <section data-markdown>
                    <textarea data-template>
                      ```python
                      names.append('Rosalind')
                      for name, count in zip(names, counts):
                          print(name)
                      ```
                      ```text
                      >>>
                      Cecilia
                      Lise
                      Marie
                      ```
                    </textarea>
                  </section>
                  <section data-markdown>
                    <textarea data-template>
                      ```python
                      import itertools
                      for name, count in itertools.zip_longest(names, counts):
                          print(f'{name}: {count}')
                      ```
                      ```text
                      >>>
                      Cecilia: 7 Lise: 4
                      Marie: 5
                      Rosalind: None
                      ```
                    </textarea>
                  </section>
                  <section>- The zip built-in function can be used to iterate over multiple iterators in parallel.</section>
                  <section>- zip creates a lazy generator that produces tuples, so it can be used on infinitely long inputs.</section>
                  <section>- zip truncates its output silently to the shortest iterator if you supply it with iterators of different lengths.</section>
                  <section>- Use the zip_longest function from the itertools built-in module if you want to use zip on iterators of unequal lengths without truncation.</section>
                </section>
                <section>
                  <section>Item 9</section>
                  <section>Avoid <u>else</u> Blocks After <u>for</u> and <u>while</u> Loops</section>
                  <section>Python loops have an <u>else</u> block that is not available in most other programming languages</section>
                  <section data-markdown>
                     <textarea data-template>
                       ```python
                       for i in range(3):
                           print('Loop', i)
                       else:
                           print('Else block!')
                       ```
                       ```text
                       >>>
                       Loop 0 
                       Loop 1
                       Loop 2
                       Else block!
                       ```
                     </textarea>
                  </section>
                  <section data-markdown>
                    <textarea data-template>
                      Using a <u>break</u> statement in a loop actually skips the <u>else</u> block
                      ```python
                      for i in range(3):
                          print('Loop', i)
                          if i == 1:
                              break
                      
                      else:
                          print('Else block!')
                      ```
                      ```text
                      >>>
                      Loop 0 
                      Loop 1
                      ```
                    </textarea>
                  </section>
                  <section data-markdown>
                    <textarea data-template>
                      The <u>else</u> block runs immediately if you loop over an empty sequence
                      ```python
                      for x in []:
                          print('Never runs')
                      else:
                          print('For Else block!')
                      ```
                      ```text
                      >>>
                      For Else block!
                      ```
                    </textarea>
                  </section>
                  <section data-markdown>
                    <textarea data-template>
                      Same happens in <u>while</u> loops that are initially <u>False</u>
                      ```python
                      while False:
                          print('Never runs')
                      else:
                          print('While Else block!')
                      ```
                      ```text
                      >>>
                      While Else block!
                      ```
                    </textarea>
                  </section>
                  <section>In summary, the <u>else</u> block after a loop runs only if the loop body did not encounter a <u>break</u> statement.</section>
                  <section>The rationale for these behaviors is that <u>else</u> blocks after loops are useful when using loops to search for something.</section>
                  <section data-markdown>
                    <textarea data-template>
                      Same happens in <u>while</u> loops that are initially <u>False</u>
                      ```python
                      a = 4
                      b = 9
                      
                      for i in range(2, min(a, b) + 1):
                          print('Testing', i)
                          if a % i == 0 and b % i == 0:
                              print('Not coprime')
                              break
                      else:
                          print('Coprime')
                      ```
                      ```text
                      >>>
                      Testing 2
                      Testing 3
                      Testing 4
                      Coprime
                      ```
                    </textarea>
                  </section>
                  <section data-markdown>
                    <textarea data-template>
                      Solution one - <b style="color:beige">Use helper function with return</b>
                      ```python
                      def coprime(a, b):
                          for i in range(2, min(a, b) + 1):
                              if a % i == 0 and b % i == 0:
                                  return False
                          return True
                      
                      assert coprime(4, 9)
                      assert not coprime(3, 6)
                      ```
                    </textarea>
                  </section>
                  <section data-markdown>
                    <textarea data-template>
                      Solution two - <b style="color:beige">Use helper function with a flag</b>
                      ```python
                      def coprime_alternate(a, b):
                          is_coprime = True
                          for i in range(2, min(a, b) + 1):
                              if a % i == 0 and b % i == 0:
                                  is_coprime = False
                                  break
                              return is_coprime
                      
                      assert coprime_alternate(4, 9)
                      assert not coprime_alternate(3, 6)
                      ```

                      Both approaches are much clearer to readers of unfamiliar code. 
                    </textarea>
                  </section>
                  <section>Avoid using <u>else</u> blocks after loops because their behavior isn’t intuitive and can be confusing.</section>
                </section>
            </div>
        </div>

        <script src="dist/reveal.js"></script>
        <script src="plugin/notes/notes.js"></script>
        <script src="plugin/markdown/markdown.js"></script>
        <script src="plugin/highlight/highlight.js"></script>
        <script>
            // More info about initialization & config:
            // - https://revealjs.com/initialization/
            // - https://revealjs.com/config/
            Reveal.initialize({
                hash: true,
                slideNumber: true,

                // Learn about plugins: https://revealjs.com/plugins/
                plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
            });
        </script>
    </body>
</html>
